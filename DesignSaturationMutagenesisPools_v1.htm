


<!--
==============================================================================

Copyright 2021-2026 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <style>
            a:link {
              color: black;
              background-color: transparent;
              text-decoration: underline;
            }
            a:visited {
              color: black;
              background-color: transparent;
              text-decoration: underline;
            }
        </style>
        <head>
            <title>Design oligo pools for saturation mutagenesis v1</title>
        </head>
        <body style="margin: 0; font-family: Helvetica; font-weight: 100; background-size: 200vw 200vh" background="brown1.jpg">
            <div style="background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 97%; height: 100%">
                <b>AI-Binder Screening Suite: DesignSaturationMutagenesisPools v1</b>
                <br>JSB Lab, University of Bonn
                <br>jsb@uni-bonn.de

                <br>
                <br>Protein name:
                <br><input id="name" value=""/>
                <br>
                <br>Primer length (default: 23):
                <br><input id="plen" value="23"/>
                <br>
                <br>Maximum mutated region length (default: 99):
                <br><input id="max_region_len" value="99"/>
                <br>
                <br>Full plasmid sequence:
                <br><input id="plasmidseq" value=""/>
                <br>
                <br>Open reading frame DNA sequence that shall be mutagenized (omit start and stop codon):
                <br><input id="orfseq" value=""/>
                <br>
                <br>Species for which to optimize the codons:
                <br>
                <select id="species">
                    <option value="ecoli">E. coli</option>
                    <option value="human">Human</option>
                </select>
                <br>
                <br>
                <button onclick="start();">Start</button>
                <br>
                <br>Note: for ordering as an oPool at IDT, open and re-save pool.txt as an Excel file
                
                <div id="save" style = "display:none">test</div>
            </div>
        </body>
    </html>

    <script>

        var plasmidseq, plasmidseq_revcom;
        function start()
        {
            human_good_codons = ["*","TGA","*","TAA","A","GCC","A","GCT","A","GCA","C","TGC","C","TGT","D","GAC","D","GAT","E","GAG","E","GAA","F","TTC","F","TTT","G","GGC","G","GGA","G","GGG","H","CAC","H","CAT","I","ATC","I","ATT","K","AAG","K","AAA","L","CTG","M","ATG","N","AAC","N","AAT","P","CCC","P","CCT","P","CCA","Q","CAG","R","AGA","R","AGG","R","CGG","R","CGC","S","AGC","S","TCC","S","TCT","S","TCA","S","AGT","T","ACC","T","ACA","T","ACT","V","GTG","V","GTC","W","TGG","Y","TAC","Y","TAT"];
            ecoli_good_codons = ["*","TAA","*","TGA","A","GCG","A","GCC","A","GCA","A","GCT","C","TGC","C","TGT","D","GAT","D","GAC","E","GAA","E","GAG","F","TTT","F","TTC","G","GGC","G","GGT","G","GGG","G","GGA","H","CAT","H","CAC","I","ATT","I","ATC","K","AAA","K","AAG","L","CTG","L","TTG","L","TTA","M","ATG","N","AAC","N","AAT","P","CCG","P","CCA","P","CCT","P","CCC","Q","CAG","Q","CAA","R","CGC","R","CGT","R","CGG","S","AGC","S","AGT","S","TCG","S","TCT","S","TCC","S","TCA","T","ACC","T","ACG","T","ACT","T","ACA","V","GTG","V","GTT","V","GTC","V","GTA","W","TGG","Y","TAT","Y","TAC"];

            //get gui data:
            var name = document.getElementById("name").value;
            var plen = document.getElementById("plen").value*1;
            var max_region_len = document.getElementById("max_region_len").value*1;
            plasmidseq = document.getElementById("plasmidseq").value.toUpperCase();
            plasmidseq_revcom = ReverseComplement(plasmidseq);
            var orfseq = document.getElementById("orfseq").value.toUpperCase();
            var full_orfseq = orfseq;

            species = document.getElementById("species").value;
            codon_table = [];
            if (species == "human")
                for (var i=0; i<human_good_codons.length/2; i++)
                    codon_table.push([human_good_codons[i*2], human_good_codons[i*2+1]]);
            if (species == "ecoli")
                for (var i=0; i<ecoli_good_codons.length/2; i++)
                    codon_table.push([ecoli_good_codons[i*2], ecoli_good_codons[i*2+1]]);

            //split orf into regions:
            var num_regions = Math.ceil(orfseq.length/max_region_len);
            var region_len = Math.ceil(orfseq.length/num_regions/3)*3;
            while (num_regions*region_len >= orfseq.length) region_len-=3;
            alert(num_regions+" regions with "+region_len+" bases each");

            var out_pool = "Pool name\tSequence", out_primer = "Primer name\tSequence", out_stats = "Primer name\tGC content (%)";

            for (var region=0; region<num_regions; region++)
            {
                orfseq = full_orfseq.substr(region*region_len, region_len);

                var orfpos = plasmidseq.search(orfseq);
                if (orfpos<0) alert("orf not found in plasmid sequence");
                
                out_pool += "\n"+name+"_"+(region+1)+"\t"+plasmidseq.substr(orfpos-plen,plen)+orfseq+plasmidseq.substr(orfpos+orfseq.length,plen);
                for (var pos=0; pos<orfseq.length/3; pos++)
                {
                  var codon = plasmidseq.substr(orfpos+pos*3, 3);
                  if (codon != "TAA" && codon != "TAG" && codon != "TGA") //don't mutate stop codons
                  {
                    var orfseq_mutated = orfseq;
                    var orfseq_mutated_ok = 0;
                    var snake_pattern = [-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8];
                    for (var num_changed_codons=0; num_changed_codons<16 && orfseq_mutated_ok==0; num_changed_codons++)
                        for (var shot=0; shot<100 && orfseq_mutated_ok==0; shot++)
                    {
                        orfseq_mutated = orfseq;
                        for (var changed_codon=0; changed_codon<num_changed_codons; changed_codon++)
                        {
                            var changed_codon_pos = pos*3+snake_pattern[changed_codon]*3;
                            if (changed_codon_pos >= 0 && changed_codon_pos+2 < orfseq.length)
                            {
                                var codon = orfseq.substr(changed_codon_pos,3);
                                var aa = Translate(codon);

                                //pick a random codon
                                var codons = [];
                                for (var c=0; c<codon_table.length; c++) if (aa == codon_table[c][0]) codons.push(codon_table[c][1]);
                                var newcodon = codon;
                                var pick = Math.floor(Math.random()*codons.length);
                                if (codons.length>0) newcodon = codons[pick];

                                orfseq_mutated = orfseq_mutated.substr(0,changed_codon_pos)+newcodon+orfseq_mutated.substr(changed_codon_pos+3);
                            }
                        }

                        //check if the distance is high enough:
                        distance = 0;
                        for (var i=0; i<orfseq.length; i++)
                            if (orfseq[i] != orfseq_mutated[i])
                                distance++;
                        if (distance >= 3) orfseq_mutated_ok = 1;
                    }
                    console.log(pos+"\t"+orfseq+"\t"+orfseq_mutated+"\t"+distance);
                    if (orfseq_mutated_ok != 1) alert("Codon scrambling failed at region "+region+" position "+pos);

                    //write to out list:
                    out_pool += "\n"+name+"_"+(region+1)+"\t"+plasmidseq.substr(orfpos-plen,plen)+orfseq_mutated.substr(0,pos*3)+"NNN"+orfseq_mutated.substr(pos*3+3)+plasmidseq.substr(orfpos+orfseq.length,plen);
                  }
                }

                //PCR primers:
                out_primer += "\n"+name+"_"+(region+1)+"_BB_fwd"+"\t"+plasmidseq.substr(orfpos+orfseq.length,plen);
                out_primer += "\n"+name+"_"+(region+1)+"_BB_rev"+"\t"+ReverseComplement(plasmidseq.substr(orfpos-plen,plen));
                out_primer += "\n"+name+"_"+(region+1)+"_pool_fwd"+"\t"+plasmidseq.substr(orfpos-40,40);
                out_primer += "\n"+name+"_"+(region+1)+"_pool_rev"+"\t"+ReverseComplement(plasmidseq.substr(orfpos+orfseq.length,40));
                out_primer += "\n"+name+"_"+(region+1)+"_miseq_fwd"+"\t"+"ACACTCTTTCCCTACACGACGCTCTTCCGATCT "+plasmidseq.substr(orfpos-plen,plen);
                out_primer += "\n"+name+"_"+(region+1)+"_miseq_rev"+"\t"+"TGACTGGAGTTCAGACGTGTGCTCTTCCGATCT "+ReverseComplement(plasmidseq.substr(orfpos+orfseq.length,plen));

                //output GC content:
                out_stats += "\n"+name+"_"+(region+1)+"_pool_fwd"+"\t"+GC_content(plasmidseq.substr(orfpos-plen,plen));
                out_stats += "\n"+name+"_"+(region+1)+"_pool_rev"+"\t"+GC_content(plasmidseq.substr(orfpos+orfseq.length,plen));
            }

            //output to GUI:
            SaveFile(out_pool, name+"_pool.txt");
            SaveFile(out_primer, name+"_primers.txt");
            SaveFile(out_stats, name+"_stats.txt");
        }

        function ReverseComplement(A)
        {
            var dummy = "";
            for (var i=0; i<A.length; i++)
            {
                if (A[A.length-1-i] == 'G') dummy += 'C';
                if (A[A.length-1-i] == 'A') dummy += 'T';
                if (A[A.length-1-i] == 'T') dummy += 'A';
                if (A[A.length-1-i] == 'C') dummy += 'G';
            }
            return dummy;
        }

        function GC_content(seq)
        {
            var gc=0;
            for (var i=0; i<seq.length; i++)
                if (seq[i] == "G" || seq[i] == "C" || seq[i] == "g" || seq[i] == "c")
                    gc++;

            return gc/seq.length*100;
        }

        var GeneticCode = "FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG";
        function Translate(seq)
        {
          var out = "";
          for (var i=0; i<seq.length/3; i++) out += GeneticCode[MakeKmer(seq.substr(i*3,3),3)];
          return out;
        }
        function MakeKmer(seq, k)
        {
            var out = 0;
            var seqlen = seq.length;

            //for (var i=8-1; i>=0; i--)
            for (var i=0; i<k; i++)
            {
                if (i >= seqlen) return -1;

                var here;
                if (seq[i] == 'T') here = 0; else
                if (seq[i] == 'C') here = 1; else
                if (seq[i] == 'A') here = 2; else
                /*if (seq[i] == 'G')*/ here = 3;

                out *= 4;
                out += here;
            }
            return out;
        }

        function SaveFile(data, filename)
        {
          var bb = new Blob([data], {type: 'text/plain'});
          var a = document.createElement('a');
          a.download = filename;
          a.href = window.URL.createObjectURL(bb);
          a.textContent = 'Klick here to save';
          a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
          document.getElementById("save").appendChild(a);
          a.click();
        }

    </script>
